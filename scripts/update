#!/usr/bin/env bash

set -e

root=$(readlink -f "$(dirname "${BASH_SOURCE[0]}")/..")

usage(){
  local name
  name=$(basename "$0")
  cat <<EOF
USAGE:
  $name                            Display usage from update.nix
  $name -h                         Display this usage
  $name [options] -P               Prompt before update
  $name [options] -a               Update all packages in $root
  $name [options] -m <maintainer>  Update packages of maintainer <maintainer>
  $name [options] -p <prefix>      Update packages matching given prefix <prefix>
  $name [options] <path>           Update package under attribute path <path>
  $name [options] -- <args>        Args to update.nix

options:
  -c Commit automatically
  -j Output packages to update in JSON format
  -w <jobs> Number of jobs in parallel
EOF
exit
}

args=()
while getopts ":Pacjhm:p:w:-:" opt; do
  case "$opt" in
    P) args+=(--argstr skip-prompt false) ;;
    a) args+=(--argstr all true) ;;
    c) args+=(--argstr commit true) ;;
    j) output_json=true;;
    m) args+=(--argstr maintainer "$OPTARG") ;;
    p) args+=(--argstr prefix "$(readlink -f "$OPTARG")") ;;
    w) args+=(--argstr max-workers "$OPTARG") ;;
    -) ;;
    h|*) usage ;;
  esac
done
shift $((OPTIND-1))

if [ "$#" -eq 1 ]
then
  args+=(--argstr path)
fi

if [ "$output_json" = "true" ]
then
  nix-shell "$root/scripts/update.nix" --argstr output-json true "${args[@]}" "$@" 2>/dev/null
else
  pushd "$root" >/dev/null
  >&2 echo nix-shell "$root/scripts/update.nix" "${args[@]}" "$@"
  nix-shell "$root/scripts/update.nix" "${args[@]}" "$@"
  popd >/dev/null
fi
