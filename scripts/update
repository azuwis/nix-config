#!/usr/bin/env bash

set -e

root=$(readlink -f "$(dirname "${BASH_SOURCE[0]}")/..")

usage(){
  local name
  name=$(basename "$0")
  cat <<EOF
USAGE:
  $name                            Display usage from update.nix
  $name -h                         Display this usage
  $name [options] -P               Prompt before update
  $name [options] -a               Update all packages in $root
  $name [options] -m <maintainer>  Update packages of maintainer <maintainer>
  $name [options] -p <prefix>      Update packages matching given prefix <prefix>
  $name [options] <path>           Update package under attribute path <path>
  $name [options] -- <args>        Args to update.nix

options:
  -c Commit automatically
  -j Output packages to update in JSON format
  -w <jobs> Number of jobs in parallel
EOF
exit
}

command=(nix-shell "$root/scripts/update.nix")
while getopts ":Pacjhm:p:w:-:" opt; do
  case "$opt" in
    P) command+=(--argstr skip-prompt false) ;;
    a) command+=(--argstr all true) ;;
    c) command+=(--argstr commit true) ;;
    j) command+=(--argstr output-json true); output_json=true;;
    m) command+=(--argstr maintainer "$OPTARG") ;;
    p) command+=(--argstr prefix "$(readlink -f "$OPTARG")") ;;
    w) command+=(--argstr max-workers "$OPTARG") ;;
    -) ;;
    h|*) usage ;;
  esac
done
shift $((OPTIND-1))

if [ "$#" -eq 1 ]
then
  command+=(--argstr path)
fi

command+=("$@")

if [ "$output_json" = "true" ]
then
  "${command[@]}" 2>/dev/null
else
  pushd "$root" >/dev/null
  >&2 echo "${command[@]}"
  "${command[@]}"
  popd >/dev/null
fi
